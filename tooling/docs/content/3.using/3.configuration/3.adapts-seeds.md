---
titre: Adaptateurs et fichiers de données statiques (seeds)
---

# Configuration des adaptateurs et des fichiers de données statiques

::alert{type="warning"}
**Les fichiers de données statiques** et **les adaptateurs** sont des **obligations** définis par le `Core` et **exécutés** par le projet `cssXX.dasboards_store`. Si vous ne les exécutez pas, l'ETL échouera. Vous devez vous référer à la documentation du comptoir (Mart) pour savoir quels fichiers de données statiques et quels adaptateurs sont requis pour chacun des répertoires.
::

Le comptoir `human_resources` et celui `education_services` utilisent tous les deux des **adaptateurs** et des **fichiers de donneés statiques** pour configurer l'ETL. Tel qu'énoncé dans la page "Architecture", ils sont utilisés pour fournir les règles d'affaires spécifiques aux CSS pour l'ETL. Les **fichiers de données statiques** sont des fichiers **csv** utilisés pour créer des dimensions qui seront utilisées en aval pour filtrer ou pour cartographier les données. Les **Adaptateurs** sont des fichiers **SQL** contenant du SQL arbitraire utilisé pour créer des dimensions ou des faits. Nous avons tendance à préférer les fichiers de données statiques plutôt que les adaptateurs puisqu'ils sont plus faciles à maintenir et à comprendre. Toutefois, il arrivera des situations où il faudra écrire du code SQL comme dans les années 80.

## Les fichiers de données statiques

### Exécution d'un fichier de données statiques
::alert{type="info"}
Le `Core` vous fournit la définition du fichier de données statiques. C'est à vous de l'alimenter. Cette définition se trouve dans le projet `core.dashboards_store/seeds/**/*/schema.yml`, dans le dossier `data`.
::

Pour exécuter un fichier de données statiques, vous devez créer un fichier `csv`, contenant les colonnes telles que spécifié dans la définition du fichier de données statiques. Ce fichier `csv` doit être enregistré dans le dossier `cssXX.dashboards_store/seeds/**/*/data`. De plus, ce fichier `csv` doit être nommé selon la définition du fichier de données statiques. Le fichier de définition comprend beaucoup d'information à propos des types de colonnes exigées par le fichier de données statiques en plus d'une description de chaque champ pour vous aider à l'alimenter. Les fichiers de données statiques devraient se trouver dans le même chemin d'accès (path) que celui ayant été utilisé par la définition du fichier de données statiques `schema.yml`.

Une fois toutes ces tâches effectuées, vous pouvez charger la base de données et tester le fichier de données statiques avec la commande suivante : 

```bash
dbt build --full-refresh --select <le nom du fichier de données statiques>
```

### Exemple :

Disons que je voudrais exécuter un fichier de données statiques nommé `exemple_seed` et défini par `core.dashboards_store/seeds/marts/exemple/schema.yml`.
Le contenu du fichier `schema.yml` est :

```yaml
seeds:
  - name: exemple_seed
    description: >
      C'est l'exemple de fichier de données statiques. 
      Ce fichier de données statiques est inutile. Il n'est qu'un ensemble d'entiers auxquels vous pourriez penser.
    # Description des champs
    columns:
      - name: seq_value
        description: Entier aléatoire
        tests:
          - not_null  # Valeurs nulles non permises
          - unique  # L'entier doit être unique
    # The seed's data type
    config:
      column_types:
        value: int
```

Je crée d'abord un `csv` vide et je le sauvegarde sous `cssXX.dashboards_store/seeds/marts/exemple/exemple_seed.csv`. Notez que le fichier de données statiques est sauvegardé dans le dossier projet `cssXX`, ** et non** dans le projet `core`. Le nom du fichier est celui indiqué à la seconde ligne de la définition du fichier de données statiques (*exemple_seed*).
À partir de la définition du fichier de données statiques, je sais que ma mise en oeuvre ne contiendra qu'une seule colonne identifiée `seq_value` remplie d'entiers uniques et non nuls. Je peux maintenant alimenter le fichier `csv` avec le contenu suivant:

```
seq_value
1
2
3
4
6
7
9
```

Je charge ensuite et je teste mon fichier de données dans la base de données. Une table sera automatiquement créée et alimentée avec le contenu du fichier `csv`. Le table se nommera `exemple_seed`. Pour ce faire, j'entrerai simplement la commande suivante : 

```bash
dbt build --full-refresh --select exemple_seed
```

## Adaptateurs

### Adaptateurs obligatoires
::alert{type=warning}
Ces adaptateurs doivent être alimentés pour que l'ETL fonctionne.
::

La prochaine table indique les définitions d'adaptateurs requises et le chemin d'accès où on devrait mettre le `sql`.

### Mise en oeuvre d'un adaptateur
::alert{type="info"}
Le `Core` ne peut que vous fournir la définition de l'adaptateur. La mise en oeuvre concrète est habituellement spécifique à chaque CSS.
::

Les adaptateurs sont décrits dans les fichiers `adapters.yml`. Ces fichiers se trouvent dans le projet `core.dashboards_store/adapters/**/*/adapters.yml`.

Pour mettre en oeuvre un adaptateur, vous devez créer un fichier `sql`, avec du SQL arbitraire. Le fichier `sql` devrait être sauvegardé sous le dossier `cssXX.dashboards_store/models/**/*/<adapter_name>.sql`. Le chemin d'accès exact devrait être celui provenant de la définition `yml` suivi du nom de l'adaptateur.  Le fichier `sql` doit se nommer selon la définition de l'adaptateur. 

Le fichier de définition donne de l'information à propos des types attendus de colonnes de données, en plus d'une description de chaque champ pour vous aider à les alimenter. Référez-vous au fichier de définition pour y trouver la spécification et la description des colonnes.

Nous essayons d'ajouter un exemple dbt `analysis` montrant comment mettre en oeuvre un adaptateur. Lorsque c'est le cas, l'analyse est sauvegardée sous `core.dashboards_store/analysis/**/*/<adapter_name>.sql`  où `**/*/<adapter_name>.sql` est le chemin d'accès à partir du fichier de définition de l'adaptateur. L'analyse est nommée selon la définition de l'adaptateur.


### Exemple :

Disons que je veux mettre en oeuvre l'adaptateur `stg_ele_prescolaiore`. Cet adaptateur est défini dans `core.dashboard_store/models/marts/education_services/adapters.yml`. La définition de l'adaptateur est :

```yaml
# core.dashboards_store/models/marts/education_services/adapters.yml
sources:
  - name: populations
    description: >
      Les populations identifient des groupes d'élèves avec des profils communs, dont élèves du régulier, élèves en adaptation scolaire ou élèves en formation générale aux adultes.
    schema: "{{ target.schema }}_educ_serv_staging"
    tables:
      - name: stg_ele_prescolaire
        description: >
          Identification des populations au préscolaire 4 ans / passe partout / préscolaire 5 ans.
        columns:
          - name: code_perm
            description: L'identifiant unique à chaque élève
          - name: id_eco
            description: L'identifiant unique d'une école par année
          - name: annee
            description: Les années scolaires où l'élève était actif

models:
  - name: stg_ele_prescolaire
    config:
      schema: "educ_serv_staging"
      <<: *x-common-tags
    description: >
      Identification de la population des élèves au préscolaire 4 ans / passe partout / préscolaire 5 ans.
    tests:
      - core_dashboards_store.resolution:
          combination_of_columns:
            - code_perm
            - id_eco
            - annee
```

1. Je crée d'abord un fichier sous `cssXX.dashboards_store/models/marts/education_services/stg_ele_prescolaire.sql`. Notez que le fichier est créé dans `cssXX` avec le même nom que celui du fichier de définition.
2. Je vérifie ensuite la définition :
   1. À partir de la définition (clé `source`), je sais que l'adaptateur devrait contenir trois colonnes: `code_perm`, `id_eco`, `annee`
   2. À partir de la définition (clé `models`), je sais que la table devrait passer un test de résolution sur les trois colonnes, signifiant qu'on ne devrait trouver aucun duplicat sur l'une ou l'autre des trois colonnes de la table.
3. Je vérifie ensuite sous le fichier `core.dashboards_store/analysis/marts/education_services/stg_ele_prescolaire.sql` pour voir si une analyse est disponible. Dans le cas présent, il y en a une. Je copie-colle l'analyse dans mon fichier `sql`, pour amorcer la mise en oeuvre de l'adaptateur.


```sql
-- cssXX.dashboards_store/models/marts/education_services/stg_ele_prescolaire.sql
select distinct ele.code_perm, eco.id_eco, eco.annee
from {{ ref("i_gpm_e_dan") }} as eledan
left join {{ ref("i_gpm_t_eco") }} as eco on eledan.id_eco = eco.id_eco
left join
    {{ ref("i_gpm_e_ele") }} as ele on eledan.fiche = ele.fiche
    /*WHERE 
    eledan.statut_don_an = 'A' AND (
        (
            eledan.ordre_ens = '1'
            AND eledan.grp_rep IN ('MA4','MA5','M41','M42')
        )

        OR (
            eledan.ordre_ens = '2'
            AND (eledan.grp_rep NOT LIKE '9%' OR eledan.grp_rep IS NULL)
            )
    )*/
```

4. Finalement, je peaufine (ou je réécris complètement) le code que je viens juste de copier-coller pour me conformer à la réalité du CSS.

